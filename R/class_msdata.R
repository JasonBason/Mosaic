#' constructRawLayout
#' 
#' Constructor function for the rawLayout S3 class, holding information on MSdata grouping and layout options in MOSAiC.
#' 
#' @param rawgrouptable a data.frame with columns File and Group , holding file paths and group names, respectively.
#' @param stem if the file paths in rawgrouptable are not full (e.g. subdirectories of the working directory), this should be the path of the working directory.
#' 
#' @export
constructRawLayout <- function(rawgrouptable, stem=NULL){
    
    MSD = list()
    MSD$stem <- stem
    MSD$rawgrouptable <- rawgrouptable
    MSD$filelist <- paste0(stem, rawgrouptable$File)
    MSD$grouping = rawGrouping(data.frame(File = MSD$filelist, Group = rawgrouptable$Group))
    MSD$settings = list(rtw = 30,
                        ppm = 5,
                        cols = 1,
                        colr = 'topo.colors',
                        alpha = 0.8)
    
    class(MSD) <- "rawLayout"
    return(MSD)
}

#' updateRawLayout
#' 
#' Updates the file path information in a rawLayout object
#' 
#' @param MSD a rawLayout object with a defined stem
#' @param stem if the file paths in rawgrouptable are not full (e.g. subdirectories of the working directory), this should be the path of the working directory.
#' 
#' @export
updateRawLayout <- function(MSD, new.stem=NULL){
    
    MSD$filelist <- gsub(MSD$stem,new.stem,MSD$filelist)
    MSD$grouping = rawGrouping(data.frame(File = MSD$filelist, Group = MSD$rawgrouptable$Group))
    MSD$stem <- new.stem
    return(MSD)
}


#' loadRawM
#' 
#' TIME CONSUMING. This step does not need to be repeated when adjusting other parameters
#' (e.g. feature list, EIC ppm or RT) Generates an R-readable data structure (a list of xcmsRaw objects) 
#' in memory from MS data files defined in the file list.
#' 
#' Note that there is an xcms function of the same name.
#' 
#' @examples
#' loadRaw(filelist)
#' 
#' @param filelist a list of mzXML or mzML files (character vector)
#' @param MSn should MSn data be read in? defaults to TRUE
#' @param workers How many cores to use (cf. BiocParallel and SnowParam, argument only used if more than 10 files are loaded).
#' @param rnames names of the xcmsRaw objects in the list returned, defaults to the filepaths of the source files.
#' 
#' @export
##Parallel enabled version for larger number of files
##NOTE: not equivalent to xcms function loadRaw
loadRawM <- function (filelist= mzxml_pos, MSn = T, workers=10, rnames = filelist){

    if (length(filelist)<=10){workers<-1}
    param <- SnowParam(workers = workers)
    rawcoll <- bplapply(filelist,xcmsRaw,  profstep=0, includeMSn = MSn, BPPARAM= param)
    names(rawcoll)<- rnames
    
    return(rawcoll)}



#' rawGrouping
#' 
#' Groups a rawgrouptable into a named list.
#' 
#' @param rawgrouptable a data.frame with columns File and Group , holding file paths and group names, respectively.
#' 
#' @export
rawGrouping <- function(rawgrouptable){
    ## Make list object of grouped column names                                        
    colme <- list()
    for (l in unique(rawgrouptable$Group)){
        colme[[l]] <- as.character(rawgrouptable$File[which(rawgrouptable$Group==l)])
    }
    
    return(colme)
}



#' multiEIC
#' 
#' Extract EICs from multiple files for multiple features.
#' 
#' @param rawdata a (named) list of xcmsRaw objects, e.g. generated by Mosaic::loadRawM
#' @param mz a data.frame with minimum (column 1) and maximum (column 2) m/z values in each row.
#' @param rt a data.frame with minimum (column 1) and maximum (column 2) retention time values (in seconds) in each row.
#' @param rnames names of the rows in the result matrix, typically the row.names of the feature table, or the filenames if byFile =T.
#' @param byFile a data.frame with columns File and Group , holding file paths and group names, respectively.
#' @param XIC deprecated
#' @param getgauss additionally, fit a gauss curve to each EIC (time consuming), defaults to FALSE
#' 
#' @export
multiEIC <- function (rawdata= rawcoll,
                      mz = data.frame(mzmin = pcame_mini$mzmin, mzmax=pcame_mini$mzmax),
                      rt = data.frame(rtmin = pcame_mini$rt-5, rtmax=pcame_mini$rt+5),
                      rnames = row.names(pcame_mini),
                      byFile = F,#if true, table will be sorted by rawfile, otherwise by feature
                      XIC = F,
                      getgauss = F
                      ){
  
   if(is.null(rt)){
     sts = lapply(rawdata,slot,"scantime")
     rt <- data.frame(rtmin = rep(min(unname(sapply(sts,min))),nrow(mz)),
                     rtmax = rep(max(unname(sapply(sts,max))),nrow(mz))
          )
   }
    
    mx <- as.matrix(cbind(mz,rt))
    
    if(nrow(mx) ==1){
    mxl <-unname(as.list(data.frame((mx[,1:2]))))
    rxl <-unname(as.list(data.frame((mx[,3:4]))))}
    else{
    mxl <-unname(as.list(data.frame(t(mx[,1:2]))))
    rxl <-unname(as.list(data.frame(t(mx[,3:4]))))
    }    
    
    fx3 <- function(ls, mz, rt, rfile, gauss = getgauss){
        ls$rt <- rfile@scantime[ls$scan]
        ls$tic <- rfile@tic[ls$scan]
        ls$mzmin <- mz[1]
        ls$mzmax <- mz[2]
        ls$rtmin <- rt[1]
        ls$rtmax <- rt[2]
        ls$intmax <- max(ls$intensity)
        ls$intsum <- sum(ls$intensity)
        ls$intmean <- mean(ls$intensity)
        if(gauss){
            return(getgauss(ls$intensity))
        }
        return(ls)
    }
    summe <- list()
    if(byFile){
    
    for(i in names(rawdata)){
        rawfile <- rawdata[[i]]
    summe[[i]] <- mapply(rawEIC, mzrange = mxl,
                    rtrange = rxl, MoreArgs=list(object=rawfile), SIMPLIFY = F)
    
    summe[[i]] <- t(mapply(fx3, summe[[i]], mz = mxl,rt=rxl, MoreArgs=list(rfile=rawfile, gauss = getgauss)))
    }
    return(summe)
    
    }else{
        for(i in c(1:nrow(mz))){
            if(!is.null(rnames)){
            featname <- rnames[i]}
            else{featname <-i}
            
            summe[[featname]] <- mapply(rawEICm, object=rawdata, 
                                        MoreArgs=list(mzrange = mxl[[i]], rtrange = rxl[[i]]), SIMPLIFY = F)
            
            summe[[featname]] <- t(mapply(fx3, summe[[featname]], rfile=rawdata, MoreArgs=list(mz = mxl[[i]], rt = rxl[[i]])))
        }
        return(summe)
    }
}

#' rawEICm
#' 
#' EICs from an xcmsRaw object, modified version of xcms::rawEIC xcmsRaw method.
#' Major difference: Handling of cases where no scan is in rt range.
#' xcms::rawEIC also drops the last scan within range, rawEICm does not.
#' 
#' @param object xcmsRaw object
#' @param mzrange a range of m/z values (numeric(2)).
#' @param rtrange a range of rt values (numeric(2)).
#' @param scanrange a range of scan number values (numeric(2)).
#' @param viewermode True to change handling of out of range rt values for the Mosaic viewer.
#' 
#' @export
rawEICm <- function(object,
                                        mzrange = numeric(),
                                        rtrange =numeric(),
                                        scanrange = numeric(),
                    viewermode = T)  {
    #print(paste(mzrange, rtrange))
  
    if (length(rtrange) >= 2 ) {
      
      if(max(rtrange) == 0){return(list(scan = 1, intensity = numeric(1)))} #quick fix for extreme cases of rt correction (rtmin and rtmax both negative and then set to 0)
            rtrange <- range(rtrange)
            
      #if sccanrange is off, just return EIC for entire range (Viewer only shows the relevant section which then is still empty)
      if(max(object@scantime) < rtrange[2] & viewermode){rtrange[2] <- max(object@scantime)}
      if(max(object@scantime) < rtrange[1] & viewermode){rtrange[1] <- min(object@scantime)}
            
      
        
        scanidx <- (object@scantime >= rtrange[1]) & (object@scantime <= rtrange[2])
        
        scanrange <- c(match(TRUE, scanidx), length(scanidx) - match(TRUE, rev(scanidx)) + 1 ) # +1 is a fix to include last scan that meets condition, fixes problem if only one scan meets condition
        
        #this is to handle exceptional situations where through retention time correction, the rtmin and rtmax both are between
        if(!any(scanidx) 
           & rtrange[2] <= max(object@scantime) 
           & rtrange[1] >= min(object@scantime)){
          scanrange <- range(c(which.min(abs(object@scantime - rtrange[1])),
                                         which.min(abs(object@scantime - rtrange[2]))))}
        
    }  else if (length(scanrange) < 2){
        scanrange <- c(1, length(object@scantime))}
    else{
        scanrange <- range(scanrange)}
    
    scanrange[1] <- max(1,scanrange[1])
    scanrange[2] <- min(length(object@scantime),scanrange[2]) #this should actually avoid the problem..
    
    if (!is.double(object@env$mz))  object@env$mz <- as.double(object@env$mz)
    if (!is.double(object@env$intensity)) object@env$intensity <- as.double(object@env$intensity)
    if (!is.integer(object@scanindex)) object@scanindex <- as.integer(object@scanindex)
    

    .Call("getEIC",object@env$mz,object@env$intensity,object@scanindex,as.double(mzrange),as.integer(scanrange),as.integer(length(object@scantime)), PACKAGE ='xcms' )


}

#' getgauss
#' 
#' fit a gauss curve into a curve (numeric vector). Note that results will be skewed if scanrate is low or heterogeneous (e.g. ddMS2 experiments).
#' 
#' @param x numeric() to fit the curve
#' 
#' @export
getgauss <- function (x){
    
    
    #substract "baseline"
    summe <- x - min(x)
    
    #normalize intensities to 1
    
    summe <- if(max(x)>0){x/max(x)}else{x}
    
    #here starts the gaussian test, cf. http://www.metabolomics-forum.com/index.php?topic=1031.0 (Krista Longnecker/Tony Larson)
    #fit gauss and let failures to fit through as corr=1
    
    fit <- try(nls(y ~ SSgauss(x, mu, sigma, h), data.frame(x =
                                                                1:length(summe), y = summe)),silent=T)
    gauss <-  if(class(fit) == "try-error")
    {
        0
    } else
    {
        #calculate correlation of summe$intensity against gaussian fit
        if(length(which(!is.na(summe-fitted(fit)))) > 4 &&
           length(!is.na(unique(summe)))>4 && length(!is.na(unique(fitted(fit))))>4)
        {
            cor <- NULL
            options(show.error.messages = FALSE)
            cor <- try(cor.test(summe,fitted(fit),method="pearson",use="complete"))
            options(show.error.messages = TRUE)
            if (!is.null(cor))
            {
                if(cor$p.value <= pval) cor$estimate else 0
            } else 0
        } else 0
        
    }
    return(gauss)}



#' bestgauss
#' 
#' return best gauss curve fit score for any of the files in rawdata for each feature returned by multiEIC.
#' 
#' @param rawdata a (named) list of xcmsRaw objects, e.g. generated by Mosaic::loadRawM
#' @param ... additional arguments passed on to multiEIC().
#' 
#' @export
bestgauss <- function(rawdata = rawcoll, ...){
    res <- multiEIC(...)
    return(data.frame(maxgauss = rowMax(matrix(unlist(res),ncol = length(rawdata)))))
}  

#' exIntensities
#' 
#' Lightweight variant of multiEIC to extract average in a file, more suitable for large featuretables.
#' 
#' @param rawfile an xcmsRaw object
#' @param mz numeric (): m/z values (same length as nrow(rtw)).
#' @param ppm m/z width (+/- ppm from values defined in mz)
#' @param rtw a data.frame with minimum (column 1) and maximum (column 2) retention time values (in seconds) in each row.
#' 
#' @export
exIntensities <- function (rawfile= rawdata[[1]] ,
                           mz = tb$mz,
                           ppm = 5,
                           rtw= data.frame(rta[[1]]$rtmin-5,rta[[1]]$rtmax+5)
                           ){
  
  #cat(paste0("Reference list with ",length(featuretable[,1])," features, iterating through list, feature #" ))
  
  
  mx <- matrix(data= c(mz-ppm*(mz/1000000),
                       mz+ppm*(mz/1000000),
                       rowMin(as.matrix(rtw)),
                       rowMax(as.matrix(rtw))), nrow= length(mz), ncol=4)
  
  mxl <-unname(as.list(data.frame(t(mx[,1:2]))))
  rxl <-unname(as.list(data.frame(t(mx[,3:4]))))
  
  
  summe <- mapply(rawEICm, mzrange = mxl,
                  rtrange = rxl, MoreArgs=list(object=rawfile, viewermode = F), SIMPLIFY = F)
  
  #substract "baseline" and get rid of scan#
  fx <- function(x) x$intensity-min(x$intensity)
  summe <- lapply(summe, fx )
  
  return(sapply(summe, mean))}

#'multiEICplus
#'
#' get EICs for adducts, isotopes and neutral loss masses
#'
#' @param adducts numeric() of mass shifts
#' @param ... all other arguments passed on to multiEIC
#' 
#' @export
multiEICplus <- function (adducts = c(0,1,2,3),
                          mz,
                          rt,
                          ...
                          #          EICsets = list(mz,
                          #                        rt,
                          #    rnames,
                          #   byFile = F,
                          #  rawdata) #if true, table will be sorted by rawfile, otherwise by feature
                          #
){
  
  liEIC <- list()
  if(is.null(adducts)){adducts <- 0}
  
  for (r in 1:length(adducts)){
    liEIC[[r]] <- mz+adducts[r]
    
  }
  
  res <- sapply(liEIC,multiEIC,rt, ...)
  #  rawdata= EICsets$rawdata,
  
  # rt = EICsets$rt,
  # rnames = EICsets$rnames,
  #byFile = F,#if true, table will be sorted by rawfile, otherwise by feature
  #XIC = F,
  #getgauss = F
  #)
  return(res)
}

#' subsetEICs
#'
#' helper function to subset output from multiEICplus
#'
#' @param EIClist matrix or list of EIC objects
#' @param group file grouping information (named list)
#' 
#' @export
subsetEICs <- function(EIClist,
                       group){
  
  maxEIC <- numeric(1)
  maxTIC <- numeric(1)
  ##subset lines
  for(i in 1:length(EIClist)){
    EIClist[[i]] <- matrix(EIClist[[i]][group,],
                           nrow = length(group),
                           ncol = ncol(EIClist[[i]]),
                           dimnames = list(rows = group,
                                           columns = colnames(EIClist[[i]])))
  }
  
  for(n in 1:length(EIClist)){
 #   if(length(group)==1){
  #    maxEIC <- max(maxEIC,unlist(EIClist[[n]][,"intensity"][[1]]))
   #   maxTIC <- max(maxTIC,unlist(EIClist[[n]][,"tic"][[1]]))
      
  #  }else{
    maxEIC <- max(maxEIC,unlist(EIClist[[n]][,"intensity"]))
    maxTIC <- max(maxTIC,unlist(EIClist[[n]][,"tic"]))
   # }
    }
  
  out <- list(EIClist,maxEIC,maxTIC)
  names(out) <- c("EIClist","maxEIC","maxTIC")
  
  return (out)
}
